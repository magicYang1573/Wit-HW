import json
import os
import math
# from simulator.coverage_extract import read_vcs_cond_coverage, read_vcs_line_coverage
import sys
sys.path.append('./simulator')
from verilator_coverage import read_line_coverage

class Tarsel_Bug_Loc_Verilator():
    def __init__(self, data_dir, case_info_file, input_files, sim_data_dict):
        self.case_info_file = case_info_file  
        self.input_files = input_files
        self.sim_data_dict = sim_data_dict
        self.read_case_info()
        self.data_dir = os.path.join(data_dir, self.case_name)

    def read_case_info(self):
        json_file_path = self.case_info_file
        with open(json_file_path, 'r') as file:
            data = json.load(file)
            self.case_name = data['case_name']
            self.module_name = data['module_name']
            self.correct_design_path = data['correct_design']
            self.buggy_design_path = data['buggy_design']
            self.testbench_path = data['testbench']
            self.input_signals = data['input_signals']
            self.bug_trigger_input = data['bug_trigger_input']
            self.module_info_path = self.buggy_design_path.split('.v')[0] + '.info'

    # output_file_1 : buggy output file
    # output_file_2 : correct output file 
    def cmp_correct_buggy_output(self, output_file_1, output_file_2, line_begin):
        
        with open(output_file_1, 'r') as f:
            lines_1 = f.readlines()

        with open(output_file_2, 'r') as f:
            lines_2 = f.readlines()

        # don't include the last '\n' generated by SV testbench $fwrite(f,"%g,%b,%b\n",...);
        line_end = min(len(lines_1)-1, len(lines_2)-1)

        # print(output_file_1, output_file_2, line_begin, line_end)

        for i in range(line_begin, line_end + 1):
            if lines_1[i].strip() != lines_2[i].strip():
                return True, line_end

        return False, line_end # No difference


    # get sorted result files from input_1 to input_n
    # return list [ [correct_output, buggy_output, buggy_cov] ...]
    # for cutted input file, correct_output = ""
    def get_sorted_result_files(self):
        sim_result_list = []
        for input_file in self.input_files:
            sim_result_list.append(self.sim_data_dict[input_file])
        return sim_result_list
    

    def get_cov_matrix(self):
        # get sorted result files from input_1 to input_n
        sim_result_list = self.get_sorted_result_files()
        
        # generate coverage of each input file result
        # we assume that each coverage report has the same format (not sure yet)
        cov_matrix = []
        branch_cov_example = read_line_coverage(sim_result_list[0][2])

        for result in sim_result_list:
            branch_cov = read_line_coverage(result[2])
            # print(result[2])
            # print(branch_cov)
            branch_cov_vec = [branch[1] for branch in branch_cov]
            cov_matrix.append(branch_cov_vec)
            assert(len(branch_cov_vec) == len(branch_cov_example))

        # sub from bottom to up
        s_num = len(cov_matrix) - 1
        while s_num>0:
            cov_matrix[s_num] = [a - b for a, b in zip(cov_matrix[s_num], cov_matrix[s_num-1])]
            s_num -= 1
        return cov_matrix, branch_cov_example

    # if the output is different from the bug-free version in the same time interval
    # e_i in vector e is 1 and otherwise 0.
    def get_error_matrix(self):
        # get sorted result files from input_1 to input_n
        sim_result_list = self.get_sorted_result_files()

        error_vec = []
        prev_line = 0
        complete_input_result = sim_result_list[-1][0]
        
        for result in sim_result_list:
            error_flag, cur_line = self.cmp_correct_buggy_output(result[1], complete_input_result, prev_line)
            error_vec.append(error_flag)
            prev_line = cur_line + 1

        return error_vec
    
    def cal_suspicious(self, cov_matrix, err_matrix):
        suspicious_list = []
        assert(len(cov_matrix) == len(err_matrix))
        
        for i in range(0, len(cov_matrix[0])):
            aep=aef=anf=anp=0
            for j in range(0, len(cov_matrix)):
                # aep: excuted and pass
                if cov_matrix[j][i]>=1 and err_matrix[j]==0:
                    aep += 1
                # aef: excuted and failed
                if cov_matrix[j][i]>=1 and err_matrix[j]==1:
                    aef += 1
                # anf: not excuted and failed
                if cov_matrix[j][i]==0 and err_matrix[j]==1:
                    anf += 1
                # anp: not excuted and pass
                if cov_matrix[j][i]==0 and err_matrix[j]==0:
                    anp += 1
        
            # aef √|aep − aef + anf − anp|.
            suspicious_list.append(aef*math.sqrt(abs(aep-aef+anf-anp)))
        
        return suspicious_list

    def report_suspicious_rank(self, suspicious_list, branch_cov_example):
        assert(len(suspicious_list)==len(branch_cov_example))
        branch_cov_num = len(branch_cov_example)
        rank_index =  [i for i, _ in sorted(enumerate(suspicious_list), key=lambda x: x[1], reverse=True)]
        # print(suspicious_list)
        # print(rank_index)

        for i, r in enumerate(rank_index):
            if r < branch_cov_num:
                print(f'Rank {i+1} (Suspicious: {suspicious_list[r]}): Branch: {branch_cov_example[r][0]}')

            
    def get_suspicious_rank(self):
        cov_matrix, branch_cov_example = self.get_cov_matrix()
        err_matrix = self.get_error_matrix()
        
        suspicious_list = self.cal_suspicious(cov_matrix, err_matrix)

        print("=== Coverage Matrix ===")
        print(cov_matrix)

        print("=== Error Matrix ===")
        print(err_matrix)

        self.report_suspicious_rank(suspicious_list, branch_cov_example)