import json
import os
import sys
import random
import copy
import numpy as np

sys.path.append('./simulator')
from run_verilator import RunConf, comp_with_verilator, sim_with_verilator, gen_basic_sim_env
from verilator_coverage import read_line_coverage
from Seed import Seed
    

class Fuzz_Engine():
    def __init__(self, data_dir, case_info_file, init_buggy_cov_path, init_buggy_vcd_path, config):
        
        self.data_dir = data_dir
        self.case_info_file = case_info_file    
        self.similarity_pattern = config['similarity']
        self.diversity_pattern = config['diversity']
        self.read_case_info()
        self.read_reg_list()

        parent_dir = os.path.dirname(data_dir)
        self.sim_run_dir_correct = os.path.join(parent_dir, 'sim-tmp/' + self.case_name + '/verilator-tmp-correct')
        self.sim_run_dir_buggy = os.path.join(parent_dir, 'sim-tmp/' + self.case_name + '/verilator-tmp-buggy')

        self.init_buggy_cov_path = init_buggy_cov_path
        self.init_buggy_vcd_path = init_buggy_vcd_path

        self.tmp_data_dir = os.path.join(data_dir, self.case_name + '/tmp')
        os.system(f'rm -rf {self.tmp_data_dir}')
        os.makedirs(self.tmp_data_dir, exist_ok=True)

        self.pass_seeds = []
        self.failed_seeds = []
        self.failed_cnt = 0
        self.max_seed_corpus_size = config['max_corpus_size']

        ## parameter for mutation 
        self.mutate_rate = config['mutate_rate']  # mutate how many position in each seed
        self.choose_init_seed_rate = config['choose_init_seed_rate']
        self.pos_pri_update_coefficient = config['pos_pri_update_coefficient']
        self.failed_loss = config['pos_failed_loss']

        # self.mutate_num_iter = 10     # in each iteration, generate how many new seeds
        # self.splice_rate = 0.3  # how many new seeds is generated by splice
        self.input_total_cnt = 0

        self.mut_pos_pri = []   # each position corresponds to the chosen score of input signals in a clock cycle (len = value.size/input_signal_num)

        self.init_bug_trigger_seed = Seed(self.buggy_input_file, '', '', init_buggy_cov_path, init_buggy_vcd_path, self.input_signals, False, self.sequential_flag)
        self.init_bug_trigger_seed.map_input_file_to_vec(self.buggy_input_file)
        self.init_bug_trigger_seed.map_cov_file_to_branch_hit(init_buggy_cov_path)
        self.init_bug_trigger_seed.map_vcd_file_to_state_trace(init_buggy_vcd_path, self.reg_list)
        self.init_bug_trigger_seed.fitness = 0
        self.failed_seeds.append(self.init_bug_trigger_seed)
        
    
    def read_case_info(self):
        json_file_path = self.case_info_file
        with open(json_file_path, 'r') as file:
            data = json.load(file)
            self.case_name = data['case_name']
            self.correct_design_path = data['correct_design']
            self.buggy_design_path = data['buggy_design']
            self.testbench_path = data['testbench']
            self.input_signals = list(data['input_signals'].items())
            self.buggy_input_file =  data['bug_trigger_input']
            self.sequential_flag = data['sequential_flag']
            self.include_files = data.get('include_files', [])


    def read_reg_list(self):
        reg_file = os.path.join(os.path.dirname(self.correct_design_path),'reg.list')
        self.reg_list = []
        if not os.path.isfile(reg_file):
            if self.similarity_pattern in ['merge', 'dtw']:
                raise FileNotFoundError(f"The file '{reg_file}' does not exist and 'similarity_pattern' is set to '{self.similarity_pattern}'.")
            else:
                return
        with open(reg_file, 'r') as file:
            for line in file:
                self.reg_list.append(line.strip())
        

    # # select a seed from pass_seeds and failed_seeds
    # # and do mutation
    # def mutate_seeds(self):
    #     seeds = self.pass_seeds + self.failed_seeds
    #     new_seeds = []
    #     for i in range(0, self.mutate_num_iter):
    #         # mut_pos = seed.mutate(mutate_rate, self.mut_pos_pri)
    #         if random.random() < self.splice_rate:
    #             selected_seed_1 = copy.deepcopy(random.choice(seeds))
    #             selected_seed_2 = random.choice(seeds)
    #             selected_seed_1.crossover(selected_seed_2)
    #             new_seeds.append(selected_seed_1)
    #         else:
    #             selected_seed = copy.deepcopy(random.choice(seeds))
    #             selected_seed.mutate(self.mutate_rate)
    #             new_seeds.append(selected_seed)
    #     return new_seeds

    # select a seed from pass_seeds and failed_seeds
    # and do mutation
    def generate_new_seed(self):
        if len(self.pass_seeds)==0:
            selected_seed = copy.deepcopy(self.init_bug_trigger_seed)
        else:
            tmp = random.random()
            if tmp < self.choose_init_seed_rate:
                selected_seed = copy.deepcopy(self.init_bug_trigger_seed)
            else:
                fitnesses = [seed.fitness for seed in self.pass_seeds]
                total_fitness = sum(fitnesses)
                probabilities = [fitness / total_fitness for fitness in fitnesses]
                selected_seed = random.choices(self.pass_seeds, weights=probabilities, k=1)[0]
                selected_seed = copy.deepcopy(selected_seed)

        mut_pos = selected_seed.mutate_with_pri(self.mutate_rate, self.mut_pos_pri)
        return selected_seed, mut_pos
        
    
    # def mutate_seeds(self):
    #     # Combine the pass and failed seeds
    #     if len(self.pass_seeds)==0:
    #         seeds = self.pass_seeds + self.failed_seeds
    #     else:
    #         seeds = self.pass_seeds
        
    #     # Calculate fitness values (assuming each seed has a 'fitness' attribute)
    #     fitness_values = np.array([seed.fitness for seed in seeds])
        
    #     # Normalize fitness values to a range [0, 1]
    #     min_fitness = fitness_values.min() - 1
    #     max_fitness = fitness_values.max()
    #     normalized_fitness = (fitness_values - min_fitness) / (max_fitness - min_fitness)
        
    #     probabilities = normalized_fitness
    #     probabilities /= probabilities.sum()  # Normalize to sum to 1

    #     new_seeds = []
    #     for i in range(self.mutate_num_iter):
    #         if random.random() < self.splice_rate:
    #             # Select two seeds based on the calculated probabilities
    #             selected_seed_1 = copy.deepcopy(np.random.choice(seeds, p=probabilities))
    #             selected_seed_2 = np.random.choice(seeds, p=probabilities)
    #             selected_seed_1.crossover(selected_seed_2)
    #             new_seeds.append(selected_seed_1)
    #         else:
    #             # Select one seed based on the calculated probabilities
    #             selected_seed = copy.deepcopy(np.random.choice(seeds, p=probabilities))
    #             selected_seed.mutate(self.mutate_rate)
    #             new_seeds.append(selected_seed)

    #     return new_seeds

    def cmp_output_same(self, output_file_1, output_file_2):
        with open(output_file_1, 'r') as f:
            lines_1 = f.readlines()
        with open(output_file_2, 'r') as f:
            lines_2 = f.readlines()

        # assert(len(lines_1)==len(lines_2))
        if len(lines_1)!=len(lines_2):
            return False
            
        for i in range(0, len(lines_1)):
            if lines_1[i].strip() != lines_2[i].strip():
                return False
        return True
    

    def fuzz(self, iter_num):
        # initialize mutate pos pri
        cycle_len = len(self.init_bug_trigger_seed.value)/len(self.input_signals)
        self.mut_pos_pri = [1 for _ in range(int(cycle_len))]

        for i in range(1, iter_num):
            # get new input files
            # mutate several positions in seed
            new_seed, mut_pos = self.generate_new_seed()

            new_seed = self.simulate_seed(new_seed)
            if new_seed.pass_flag:
                if self.diversity_pattern=='none':
                    self.pass_seeds.append(new_seed)
                else:
                    diverse_score, same_flag = self.cal_diverse_score(new_seed)
                    if same_flag==False:
                        self.update_mut_pos_pri(mut_pos, diverse_score, new_seed.pass_flag)
                        self.pass_seeds.append(new_seed)
            else:
                if self.diversity_pattern=='none':
                    self.failed_seeds.append(new_seed)
                else:
                    self.update_mut_pos_pri(mut_pos, 0, new_seed.pass_flag)
                    self.failed_seeds.append(new_seed)

                # self.failed_cnt += 1

                       
            print(f'Generate {i} new seeds: pass {len(self.pass_seeds)}, failed {len(self.failed_seeds)}')
            # print(f'Generate {i} new seeds: pass {len(self.pass_seeds)}, failed {self.failed_cnt}')

            
            self.update_seed()

    

    
    def simulate_seed(self, seed):
        self.input_total_cnt += 1
        input_file_path = os.path.join(self.tmp_data_dir, 'input-'+str(self.input_total_cnt))
        seed.map_vec_to_input_file(input_file_path)

        verilator_run_conf = RunConf(
            # defines=[("DUMP_TRACE", "1")],
            timeout=30,
        )

        # simulate correct design
        gen_basic_sim_env(self.sim_run_dir_correct, [], '', input_file_path)
        verilator_sim_success = sim_with_verilator(self.sim_run_dir_correct, verilator_run_conf)
        
        output_file = os.path.join(self.sim_run_dir_correct, "output-signals.txt")
        prefix = "correct-" + input_file_path.split('/')[-1].split('.')[0] + '-'
        correct_output_data_file = os.path.join(self.tmp_data_dir, prefix + "output-signals.txt")
        os.system(f'cp {output_file} {correct_output_data_file}')

        # simulate buggy design
        gen_basic_sim_env(self.sim_run_dir_buggy, [], '', input_file_path)
        verilator_sim_success = sim_with_verilator(self.sim_run_dir_buggy, verilator_run_conf)
        
        output_file = os.path.join(self.sim_run_dir_buggy, "output-signals.txt")
        prefix = "buggy-" + input_file_path.split('/')[-1].split('.')[0] + '-'
        buggy_output_data_file = os.path.join(self.tmp_data_dir, prefix + "output-signals.txt")
        os.system(f'cp {output_file} {buggy_output_data_file}')

        cov_log = os.path.join(self.sim_run_dir_buggy, "coverage.dat")
        prefix = "buggy-" + input_file_path.split('/')[-1].split('.')[0] + '-'
        buggy_cov_data_file = os.path.join(self.tmp_data_dir, prefix + "coverage")
        os.system(f'cp {cov_log} {buggy_cov_data_file}')

        vcd_log = os.path.join(self.sim_run_dir_buggy, "dump.vcd")
        prefix = "buggy-" + input_file_path.split('/')[-1].split('.')[0] + '-'
        buggy_vcd_data_file = os.path.join(self.tmp_data_dir, prefix + "vcd")
        os.system(f'cp {vcd_log} {buggy_vcd_data_file}')

        seed.map_cov_file_to_branch_hit(buggy_cov_data_file)
        seed.map_out_file_to_out_trace(correct_output_data_file, buggy_output_data_file)
        seed.map_vcd_file_to_state_trace(buggy_vcd_data_file, self.reg_list)

        pass_flag = self.cmp_output_same(correct_output_data_file, buggy_output_data_file)
        seed.set_pass_flag(pass_flag)

        return seed

    # calcutae the diversity of new seed
    def cal_diverse_score(self, seed):

        same_flag = False   # new seed is the same with one of the exsisting seed
        if len(self.pass_seeds)==0:
            return 1, same_flag
        
        score_sum = 0
        for old_seed in self.pass_seeds:
            distance = seed.cal_distance(old_seed, self.similarity_pattern)
            if distance==0:
                same_flag = True
                return 0, same_flag
            score_sum += distance
        score_sum /= len(self.pass_seeds)

        return score_sum, same_flag
    
    def update_mut_pos_pri(self, mut_pos, diverse_score, pass_flag):
        alpha = self.pos_pri_update_coefficient
        if pass_flag:
            for i in mut_pos:
                self.mut_pos_pri[i] = (1-alpha)*self.mut_pos_pri[i] + alpha*diverse_score
        else:
            for i in mut_pos:
                self.mut_pos_pri[i] = (1-alpha)*self.mut_pos_pri[i] + alpha*self.failed_loss

        # print(self.mut_pos_pri)

    def update_seed(self):

        for seed in self.pass_seeds:
            seed.cal_fitness(self.init_bug_trigger_seed, self.similarity_pattern)
        
        self.pass_seeds.sort(key=lambda s: s.fitness, reverse=True)

        seeds_to_keep = self.pass_seeds[:self.max_seed_corpus_size]
        seeds_to_remove = self.pass_seeds[self.max_seed_corpus_size:]
        self.pass_seeds = seeds_to_keep

        for seed in seeds_to_remove:
            seed.delete()

        # for seed in self.pass_seeds:
        #     print(seed.fitness)

        if len(self.pass_seeds)>0:
            average_fitness = sum(seed.fitness for seed in self.pass_seeds[:10]) / len(self.pass_seeds[:10])
            best_fitness = self.pass_seeds[0].fitness 
            print(f"Top-10 Average fitness: {average_fitness}; Best fitness: {best_fitness}")
        
        
    def get_seeds(self):
        # return self.pass_seeds, self.failed_seeds
        return self.pass_seeds, [self.init_bug_trigger_seed]

    def get_cov_example(self):
        coverage = read_line_coverage(self.init_buggy_cov_path)
        return coverage

    # used for distance statistic 
    def show_distance(self):
        log_file = os.path.join(self.data_dir, self.case_name + '/distance.txt')
        distance_list = []
        for seed in self.pass_seeds:
            cov_distance = seed.cal_distance(self.init_bug_trigger_seed, 'cov')
            if self.sequential_flag==True:
                state_distance = seed.cal_distance(self.init_bug_trigger_seed, 'dtw')
            else:
                state_distance = 0
            sum_distance = seed.cal_distance(self.init_bug_trigger_seed, 'merge')
            distance_list.append([cov_distance, state_distance, sum_distance])
        with open(log_file, 'w') as f:
            for distances in distance_list:
                f.write(','.join(map(str, distances)) + '\n')